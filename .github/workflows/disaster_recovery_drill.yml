name: Disaster Recovery Automation

on:
  schedule:
    - cron: '0 3 * * 0'  # Sunday 3 AM UTC weekly
  workflow_dispatch:
    inputs:
      drill_mode:
        description: "Disaster recovery drill mode"
        type: choice
        required: true
        default: "staging_cold_start"
        options:
          - "staging_cold_start"
          - "production_backup"
          - "full_recovery_test"
          - "rollback_simulation"
      target_org:
        description: "Target Fly.io organization"
        type: choice
        required: true
        default: "staging"
        options:
          - "staging"
          - "pay-ready"
      recreate_apps:
        description: "Recreate all apps (destroys existing)"
        type: boolean
        default: true
      measure_recovery_time:
        description: "Measure and record recovery times"
        type: boolean
        default: true

concurrency:
  group: disaster-recovery-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write
  id-token: write

env:
  FLY_PRIMARY_REGION: iad
  CACHE_BUSTER: ${{ github.run_id }}-${{ github.run_attempt }}
  DRILL_WEBHOOK_URL: ${{ secrets.DRILL_WEBHOOK_URL }}
  # Staging URLs for cold-start testing
  STAGING_DASHBOARD_URL: https://sophiaai-dashboard-staging.fly.dev
  STAGING_MCP_REPO_URL: https://sophiaai-mcp-repo-staging.fly.dev
  STAGING_MCP_RESEARCH_URL: https://sophiaai-mcp-research-staging.fly.dev
  STAGING_MCP_CONTEXT_URL: https://sophiaai-mcp-context-staging.fly.dev
  STAGING_MCP_BUSINESS_URL: https://sophiaai-mcp-business-staging.fly.dev

jobs:
  disaster-recovery-preparation:
    name: DR Preparation & Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      drill-mode: ${{ steps.setup.outputs.drill_mode }}
      target-org: ${{ steps.setup.outputs.target_org }}
      recovery-start-time: ${{ steps.setup.outputs.recovery_start_time }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup drill parameters
        id: setup
        run: |
          # Determine drill mode and target
          DRILL_MODE="${{ inputs.drill_mode || 'staging_cold_start' }}"
          TARGET_ORG="${{ inputs.target_org || 'staging' }}"
          RECOVERY_START=$(date +%s)
          
          echo "üö® Disaster Recovery Drill Initiated"
          echo "Mode: $DRILL_MODE"
          echo "Target Organization: $TARGET_ORG"
          echo "Start Time: $(date -u)"
          
          echo "drill_mode=$DRILL_MODE" >> $GITHUB_OUTPUT
          echo "target_org=$TARGET_ORG" >> $GITHUB_OUTPUT
          echo "recovery_start_time=$RECOVERY_START" >> $GITHUB_OUTPUT
          
          # Create drill metadata
          mkdir -p proofs/disaster_recovery/$(date +%Y-%m-%d)
          cat > proofs/disaster_recovery/$(date +%Y-%m-%d)/drill_metadata.json <<EOF
          {
            "drill_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "date": "$(date +%Y-%m-%d)",
            "mode": "$DRILL_MODE",
            "target_org": "$TARGET_ORG",
            "recreate_apps": ${{ inputs.recreate_apps || true }},
            "measure_recovery_time": ${{ inputs.measure_recovery_time || true }},
            "recovery_start_timestamp": $RECOVERY_START,
            "triggered_by": "${{ github.actor }}"
          }
          EOF

      - name: Validate disaster recovery prerequisites
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          STAGING_FLY_TOKEN: ${{ secrets.STAGING_FLY_TOKEN }}
        run: |
          echo "üîç Validating DR prerequisites..."
          
          validation_errors=""
          
          # Check required tokens
          if [ "${{ steps.setup.outputs.target_org }}" = "staging" ] && [ -z "$STAGING_FLY_TOKEN" ]; then
            validation_errors="$validation_errors\n‚ùå STAGING_FLY_TOKEN required for staging drills"
          elif [ "${{ steps.setup.outputs.target_org }}" = "pay-ready" ] && [ -z "$FLY_API_TOKEN" ]; then
            validation_errors="$validation_errors\n‚ùå FLY_API_TOKEN required for production drills"
          fi
          
          # Check GitHub secrets for app secrets
          if [ -z "${{ secrets.FLY_APP_SECRETS_JSON }}" ]; then
            validation_errors="$validation_errors\n‚ö†Ô∏è FLY_APP_SECRETS_JSON not available - apps may not function correctly"
          fi
          
          if [ -n "$validation_errors" ]; then
            echo -e "$validation_errors"
            echo "‚ùå DR prerequisites validation failed"
            exit 1
          else
            echo "‚úÖ All DR prerequisites validated"
          fi

      - name: Send drill start notification
        if: ${{ env.DRILL_WEBHOOK_URL != '' }}
        env:
          WEBHOOK_URL: ${{ env.DRILL_WEBHOOK_URL }}
        run: |
          echo "üì° Sending DR drill start notification..."
          
          payload=$(cat <<EOF
          {
            "text": "üö® Disaster Recovery Drill Started",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Disaster Recovery Drill Initiated*\n\n*Mode:* ${{ steps.setup.outputs.drill_mode }}\n*Target:* ${{ steps.setup.outputs.target_org }}\n*Drill ID:* ${{ github.run_id }}\n*Started by:* ${{ github.actor }}\n*Time:* $(date -u)"
                }
              }
            ]
          }
          EOF
          )
          
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send drill notification"

  cold-start-recovery:
    name: Cold Start Recovery Test
    runs-on: ubuntu-latest
    needs: disaster-recovery-preparation
    if: ${{ contains(inputs.drill_mode, 'cold_start') || inputs.drill_mode == '' }}
    timeout-minutes: 45
    environment:
      name: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && 'production' || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install flyctl and tools
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bc

      - name: Authenticate with target organization
        env:
          FLY_API_TOKEN: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && secrets.FLY_API_TOKEN || secrets.STAGING_FLY_TOKEN }}
          TARGET_ORG: ${{ needs.disaster-recovery-preparation.outputs.target-org }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing authentication token for $TARGET_ORG"
            exit 1
          fi
          
          echo "FLY_ORG=$TARGET_ORG" >> $GITHUB_ENV
          echo "‚úÖ Authenticated with $TARGET_ORG organization"

      - name: Destroy existing apps (cold start simulation)
        if: ${{ inputs.recreate_apps == true }}
        env:
          FLY_API_TOKEN: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && secrets.FLY_API_TOKEN || secrets.STAGING_FLY_TOKEN }}
        run: |
          echo "üî• COLD START: Destroying existing apps..."
          
          # Get suffix based on org
          SUFFIX=""
          if [ "${{ env.FLY_ORG }}" = "staging" ]; then
            SUFFIX="-staging"
          elif [ "${{ env.FLY_ORG }}" = "pay-ready" ]; then
            SUFFIX="-v2"
          fi
          
          apps=(
            "sophiaai-dashboard$SUFFIX"
            "sophiaai-mcp-repo$SUFFIX"
            "sophiaai-mcp-research$SUFFIX"
            "sophiaai-mcp-context$SUFFIX"
            "sophiaai-mcp-business$SUFFIX"
            "sophiaai-jobs$SUFFIX"
          )
          
          for app in "${apps[@]}"; do
            echo "Destroying app: $app"
            flyctl apps destroy "$app" --yes || echo "App $app didn't exist or couldn't be destroyed"
          done
          
          echo "‚úÖ Apps destroyed - cold start environment prepared"

      - name: Record recovery phase start times
        if: ${{ inputs.measure_recovery_time == true }}
        run: |
          echo "‚è±Ô∏è Recording recovery phase timings..."
          mkdir -p proofs/disaster_recovery/$(date +%Y-%m-%d)
          
          PHASE_START=$(date +%s)
          echo "APP_CREATION_START=$PHASE_START" >> $GITHUB_ENV
          echo "App creation phase started at: $(date -u)"

      - name: Recreate apps from infrastructure as code
        env:
          FLY_API_TOKEN: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && secrets.FLY_API_TOKEN || secrets.STAGING_FLY_TOKEN }}
        run: |
          echo "üèóÔ∏è Recreating apps from fly.toml configurations..."
          
          # Get suffix based on org
          SUFFIX=""
          if [ "${{ env.FLY_ORG }}" = "staging" ]; then
            SUFFIX="-staging"
          elif [ "${{ env.FLY_ORG }}" = "pay-ready" ]; then
            SUFFIX="-v2"
          fi
          
          apps_created=0
          
          # Dashboard
          echo "Creating dashboard app..."
          flyctl apps create "sophiaai-dashboard$SUFFIX" --org "${{ env.FLY_ORG }}" --region "$FLY_PRIMARY_REGION" || echo "App already exists"
          apps_created=$((apps_created + 1))
          
          # MCP Services
          for service in mcp-repo mcp-research mcp-context mcp-business; do
            echo "Creating $service app..."
            flyctl apps create "sophiaai-$service$SUFFIX" --org "${{ env.FLY_ORG }}" --region "$FLY_PRIMARY_REGION" || echo "App already exists"
            apps_created=$((apps_created + 1))
          done
          
          # Jobs service
          echo "Creating jobs app..."
          flyctl apps create "sophiaai-jobs$SUFFIX" --org "${{ env.FLY_ORG }}" --region "$FLY_PRIMARY_REGION" || echo "App already exists"
          apps_created=$((apps_created + 1))
          
          echo "APPS_CREATED=$apps_created" >> $GITHUB_ENV
          echo "‚úÖ Created $apps_created applications"

      - name: Seed critical secrets
        env:
          FLY_API_TOKEN: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && secrets.FLY_API_TOKEN || secrets.STAGING_FLY_TOKEN }}
          FLY_APP_SECRETS_JSON: ${{ secrets.FLY_APP_SECRETS_JSON }}
        run: |
          if [ -z "$FLY_APP_SECRETS_JSON" ]; then
            echo "‚ö†Ô∏è FLY_APP_SECRETS_JSON not provided, skipping secrets seeding"
            echo "SECRETS_SEEDED=0" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "üîê Seeding critical secrets to recovered apps..."
          
          # Get suffix based on org
          SUFFIX=""
          if [ "${{ env.FLY_ORG }}" = "staging" ]; then
            SUFFIX="-staging"
          elif [ "${{ env.FLY_ORG }}" = "pay-ready" ]; then
            SUFFIX="-v2"
          fi
          
          apps=(
            "sophiaai-dashboard$SUFFIX"
            "sophiaai-mcp-repo$SUFFIX"
            "sophiaai-mcp-research$SUFFIX"
            "sophiaai-mcp-context$SUFFIX"
            "sophiaai-mcp-business$SUFFIX"
            "sophiaai-jobs$SUFFIX"
          )
          
          secrets_count=0
          
          for app in "${apps[@]}"; do
            echo "Setting secrets for: $app"
            
            echo "$FLY_APP_SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while read -r secret; do
              key=$(echo "$secret" | cut -d'=' -f1)
              value=$(echo "$secret" | cut -d'=' -f2-)
              
              if [ -n "$value" ] && [ "$value" != "null" ]; then
                flyctl secrets set "$key=$value" -a "$app" || echo "  Failed to set $key for $app"
                secrets_count=$((secrets_count + 1))
              fi
            done
          done
          
          echo "SECRETS_SEEDED=$secrets_count" >> $GITHUB_ENV
          echo "‚úÖ Seeded secrets to recovered applications"

      - name: Record app creation completion
        if: ${{ inputs.measure_recovery_time == true }}
        run: |
          APP_CREATION_END=$(date +%s)
          APP_CREATION_DURATION=$((APP_CREATION_END - APP_CREATION_START))
          
          echo "APP_CREATION_DURATION=$APP_CREATION_DURATION" >> $GITHUB_ENV
          echo "‚è±Ô∏è App creation took ${APP_CREATION_DURATION} seconds"

      - name: Deploy applications with cold start timing
        env:
          FLY_API_TOKEN: ${{ needs.disaster-recovery-preparation.outputs.target-org == 'pay-ready' && secrets.FLY_API_TOKEN || secrets.STAGING_FLY_TOKEN }}
        run: |
          echo "üöÄ Deploying applications for disaster recovery validation..."
          
          DEPLOYMENT_START=$(date +%s)
          echo "DEPLOYMENT_START=$DEPLOYMENT_START" >> $GITHUB_ENV
          
          # Get suffix based on org  
          SUFFIX=""
          if [ "${{ env.FLY_ORG }}" = "staging" ]; then
            SUFFIX="-staging"
          elif [ "${{ env.FLY_ORG }}" = "pay-ready" ]; then
            SUFFIX="-v2"
          fi
          
          # Deploy dashboard
          echo "Deploying dashboard..."
          cd apps/dashboard
          flyctl deploy \
            --config ./fly.toml \
            --dockerfile ./Dockerfile.static \
            --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
            --remote-only \
            --yes || echo "Dashboard deployment failed"
          cd ../..
          
          # Deploy MCP services
          for service in mcp-github mcp-research mcp-context mcp-business; do
            echo "Deploying $service..."
            cd "services/$service"
            flyctl deploy \
              --config ./fly.toml \
              --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
              --remote-only \
              --yes || echo "$service deployment failed"
            cd ../..
          done
          
          # Deploy jobs
          echo "Deploying jobs service..."
          cd jobs
          flyctl deploy \
            --config ./fly.toml \
            --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
            --remote-only \
            --yes || echo "Jobs deployment failed"
          cd ..
          
          DEPLOYMENT_END=$(date +%s)
          DEPLOYMENT_DURATION=$((DEPLOYMENT_END - DEPLOYMENT_START))
          echo "DEPLOYMENT_DURATION=$DEPLOYMENT_DURATION" >> $GITHUB_ENV
          echo "‚è±Ô∏è Deployment took ${DEPLOYMENT_DURATION} seconds"

      - name: Validate recovered services
        run: |
          echo "üè• Validating recovered services..."
          
          VALIDATION_START=$(date +%s)
          
          # Determine URLs based on org
          if [ "${{ env.FLY_ORG }}" = "staging" ]; then
            urls=(
              "$STAGING_DASHBOARD_URL"
              "$STAGING_MCP_REPO_URL"
              "$STAGING_MCP_RESEARCH_URL"
              "$STAGING_MCP_CONTEXT_URL"
              "$STAGING_MCP_BUSINESS_URL"
            )
          else
            # Production URLs would be used here
            urls=(
              "https://sophiaai-dashboard-v2.fly.dev"
              "https://sophiaai-mcp-repo-v2.fly.dev"
              "https://sophiaai-mcp-research-v2.fly.dev"
              "https://sophiaai-mcp-context-v2.fly.dev"
              "https://sophiaai-mcp-business-v2.fly.dev"
            )
          fi
          
          services_healthy=0
          total_services=${#urls[@]}
          
          echo "Waiting 60 seconds for services to start..."
          sleep 60
          
          for url in "${urls[@]}"; do
            echo "Testing $url/healthz"
            
            for attempt in {1..5}; do
              if curl -f -sS "$url/healthz" > /dev/null 2>&1; then
                echo "‚úÖ $url is healthy"
                services_healthy=$((services_healthy + 1))
                break
              else
                echo "‚ö†Ô∏è $url attempt $attempt failed, retrying..."
                if [ $attempt -eq 5 ]; then
                  echo "‚ùå $url failed all health checks"
                fi
                sleep 10
              fi
            done
          done
          
          VALIDATION_END=$(date +%s)
          VALIDATION_DURATION=$((VALIDATION_END - VALIDATION_START))
          
          echo "SERVICES_HEALTHY=$services_healthy" >> $GITHUB_ENV
          echo "TOTAL_SERVICES=$total_services" >> $GITHUB_ENV
          echo "VALIDATION_DURATION=$VALIDATION_DURATION" >> $GITHUB_ENV
          
          success_rate=$(echo "scale=2; $services_healthy * 100 / $total_services" | bc)
          echo "SERVICE_SUCCESS_RATE=$success_rate" >> $GITHUB_ENV
          
          echo "üè• Recovery validation: $services_healthy/$total_services services healthy (${success_rate}%)"

      - name: Generate recovery report
        if: always()
        run: |
          echo "üìä Generating disaster recovery report..."
          mkdir -p proofs/disaster_recovery/$(date +%Y-%m-%d)
          
          TOTAL_RECOVERY_TIME=$(($(date +%s) - ${{ needs.disaster-recovery-preparation.outputs.recovery-start-time }}))
          
          recovery_report=$(cat <<EOF
          {
            "drill_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "date": "$(date +%Y-%m-%d)",
            "drill_mode": "${{ needs.disaster-recovery-preparation.outputs.drill-mode }}",
            "target_org": "${{ needs.disaster-recovery-preparation.outputs.target-org }}",
            "recovery_metrics": {
              "total_recovery_time_seconds": $TOTAL_RECOVERY_TIME,
              "app_creation_duration_seconds": ${APP_CREATION_DURATION:-0},
              "deployment_duration_seconds": ${DEPLOYMENT_DURATION:-0},
              "validation_duration_seconds": ${VALIDATION_DURATION:-0},
              "apps_created": ${APPS_CREATED:-0},
              "secrets_seeded": ${SECRETS_SEEDED:-0},
              "services_healthy": ${SERVICES_HEALTHY:-0},
              "total_services": ${TOTAL_SERVICES:-0},
              "success_rate_percentage": ${SERVICE_SUCCESS_RATE:-0}
            },
            "status": "$( [ "${SERVICES_HEALTHY:-0}" -eq "${TOTAL_SERVICES:-0}" ] && echo "success" || echo "partial_failure" )"
          }
          EOF
          )
          
          echo "$recovery_report" | jq . > "proofs/disaster_recovery/$(date +%Y-%m-%d)/recovery_report_${{ github.run_id }}.json"
          
          echo "‚è±Ô∏è Total Recovery Time: ${TOTAL_RECOVERY_TIME} seconds"
          echo "üìä Success Rate: ${SERVICE_SUCCESS_RATE:-0}%"

      - name: Commit recovery proofs
        if: always()
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/disaster_recovery/
          
          if ! git diff --cached --quiet; then
            git commit -m "[disaster-recovery] DR drill completed - $(date +%Y-%m-%d) (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
            echo "‚úÖ Recovery proofs committed"
          fi

  disaster-recovery-notification:
    name: DR Drill Results & Notification
    runs-on: ubuntu-latest
    needs: [disaster-recovery-preparation, cold-start-recovery]
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull recovery results
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Send completion notification
        if: ${{ env.DRILL_WEBHOOK_URL != '' }}
        env:
          WEBHOOK_URL: ${{ env.DRILL_WEBHOOK_URL }}
        run: |
          echo "üì° Sending DR drill completion notification..."
          
          status="${{ needs.cold-start-recovery.result }}"
          status_icon="‚úÖ"
          status_text="Success"
          
          if [ "$status" != "success" ]; then
            status_icon="‚ö†Ô∏è"
            status_text="Completed with issues"
          fi
          
          payload=$(cat <<EOF
          {
            "text": "${status_icon} Disaster Recovery Drill Complete",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Disaster Recovery Drill Complete*\n\n*Status:* ${status_icon} ${status_text}\n*Mode:* ${{ needs.disaster-recovery-preparation.outputs.drill-mode }}\n*Target:* ${{ needs.disaster-recovery-preparation.outputs.target-org }}\n*Drill ID:* ${{ github.run_id }}\n*Completed:* $(date -u)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Recovery Results:*\n‚Ä¢ Cold Start Recovery: ${{ needs.cold-start-recovery.result }}\n\n*Next Steps:*\n‚Ä¢ Review recovery report in \`proofs/disaster_recovery/\`\n‚Ä¢ Update recovery procedures if needed"
                }
              }
            ]
          }
          EOF
          )
          
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send completion notification"

      - name: Generate drill summary
        run: |
          echo "# üö® Disaster Recovery Drill Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Drill ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** ${{ needs.disaster-recovery-preparation.outputs.drill-mode }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target:** ${{ needs.disaster-recovery-preparation.outputs.target-org }}" >> $GITHUB_STEP_SUMMARY
          echo "**Completed:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Cold Start Recovery:** ${{ needs.cold-start-recovery.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìÅ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Recovery report: \`proofs/disaster_recovery/$(date +%Y-%m-%d)/recovery_report_${{ github.run_id }}.json\`" >> $GITHUB_STEP_SUMMARY
          echo "- Drill metadata: \`proofs/disaster_recovery/$(date +%Y-%m-%d)/drill_metadata.json\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéØ Action Items" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Review recovery times and optimize if needed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Update disaster recovery runbook" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Schedule next drill" >> $GITHUB_STEP_SUMMARY