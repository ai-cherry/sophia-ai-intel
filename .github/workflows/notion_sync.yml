name: Notion Knowledge Sync

on:
  schedule:
    # Run nightly at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      sync_type:
        description: 'Type of sync to perform'
        required: false
        default: 'incremental'
        type: choice
        options:
          - incremental
          - full
      force_embed:
        description: 'Force regeneration of embeddings'
        required: false
        default: 'false'
        type: boolean

jobs:
  notion-knowledge-sync:
    runs-on: ubuntu-latest
    if: github.repository == 'ai-cherry/sophia-ai-intel'
    
    environment: production
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install --upgrade pip
        pip install notion-client openai asyncpg python-dotenv
    
    - name: Check Notion integration secrets
      run: |
        if [ -z "${{ secrets.NOTION_API_KEY }}" ]; then
          echo "⚠️ NOTION_API_KEY not configured - creating normalized error proof"
          cat > proofs/knowledge/notion_sync_blocked.json << EOF
        {
          "status": "failure",
          "query": "Notion knowledge sync integration",
          "results": [],
          "summary": {
            "text": "Notion API key not configured - knowledge sync cannot proceed",
            "confidence": 1.0,
            "model": "n/a",
            "sources": []
          },
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "execution_time_ms": 0,
          "errors": [
            {
              "provider": "notion_api",
              "code": "MISSING_API_KEY",
              "message": "NOTION_API_KEY secret not configured in GitHub Actions"
            }
          ]
        }
        EOF
          echo "::error::Notion API key not configured"
          exit 1
        fi
        
        if [ -z "${{ secrets.NOTION_DATABASE_ID }}" ]; then
          echo "⚠️ NOTION_DATABASE_ID not configured"
          echo "::warning::Notion database ID not configured - will use default knowledge pages"
        fi
    
    - name: Create Notion sync script
      run: |
        cat > notion_sync.py << 'EOF'
        #!/usr/bin/env python3
        """
        Notion Knowledge Sync
        Syncs knowledge pages and OKRs from Notion to Qdrant for semantic search
        """
        
        import asyncio
        import json
        import logging
        import os
        import time
        from datetime import datetime, timezone
        from typing import Dict, List, Optional
        
        import asyncpg
        import openai
        from notion_client import Client
        from openai import AsyncOpenAI
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class NotionKnowledgeSync:
            def __init__(self, notion_token: str, openai_api_key: str, database_url: str):
                self.notion = Client(auth=notion_token)
                self.openai_client = AsyncOpenAI(api_key=openai_api_key)
                self.database_url = database_url
                self.embedding_model = "text-embedding-3-small"
                self.embedding_dimensions = 1536
            
            async def get_db_connection(self):
                return await asyncpg.connect(self.database_url)
            
            async def get_notion_pages(self, database_id: Optional[str] = None) -> List[Dict]:
                """Retrieve pages from Notion database or search"""
                pages = []
                
                try:
                    if database_id:
                        # Query specific database
                        results = self.notion.databases.query(database_id=database_id)
                    else:
                        # Search for knowledge-related pages
                        results = self.notion.search(
                            query="knowledge",
                            filter={"property": "object", "value": "page"},
                            sort={"direction": "descending", "timestamp": "last_edited_time"}
                        )
                    
                    for page in results.get('results', []):
                        page_content = await self.extract_page_content(page['id'])
                        if page_content:
                            pages.append({
                                'id': page['id'],
                                'title': self.extract_page_title(page),
                                'content': page_content,
                                'last_edited': page['last_edited_time'],
                                'url': page.get('url', ''),
                                'properties': page.get('properties', {})
                            })
                
                except Exception as e:
                    logger.error(f"Error fetching Notion pages: {e}")
                
                return pages
            
            def extract_page_title(self, page: Dict) -> str:
                """Extract title from Notion page"""
                properties = page.get('properties', {})
                
                # Try different title property names
                for title_key in ['Name', 'Title', 'title', 'name']:
                    if title_key in properties:
                        title_prop = properties[title_key]
                        if title_prop.get('type') == 'title' and title_prop.get('title'):
                            return ''.join([t['plain_text'] for t in title_prop['title']])
                
                # Fallback to page object title
                if 'properties' in page and 'title' in page['properties']:
                    return page['properties']['title']['title'][0]['plain_text']
                
                return f"Untitled Page {page['id'][:8]}"
            
            async def extract_page_content(self, page_id: str) -> Optional[str]:
                """Extract content from Notion page"""
                try:
                    blocks = self.notion.blocks.children.list(block_id=page_id)
                    content_parts = []
                    
                    for block in blocks.get('results', []):
                        content = self.extract_block_content(block)
                        if content:
                            content_parts.append(content)
                    
                    return '\n'.join(content_parts)
                
                except Exception as e:
                    logger.error(f"Error extracting content from page {page_id}: {e}")
                    return None
            
            def extract_block_content(self, block: Dict) -> Optional[str]:
                """Extract content from a Notion block"""
                block_type = block.get('type')
                
                if block_type in ['paragraph', 'heading_1', 'heading_2', 'heading_3']:
                    rich_text = block[block_type].get('rich_text', [])
                    return ''.join([t['plain_text'] for t in rich_text])
                
                elif block_type == 'bulleted_list_item':
                    rich_text = block[block_type].get('rich_text', [])
                    text = ''.join([t['plain_text'] for t in rich_text])
                    return f"• {text}"
                
                elif block_type == 'numbered_list_item':
                    rich_text = block[block_type].get('rich_text', [])
                    text = ''.join([t['plain_text'] for t in rich_text])
                    return f"1. {text}"
                
                elif block_type == 'quote':
                    rich_text = block[block_type].get('rich_text', [])
                    text = ''.join([t['plain_text'] for t in rich_text])
                    return f"> {text}"
                
                elif block_type == 'code':
                    rich_text = block[block_type].get('rich_text', [])
                    text = ''.join([t['plain_text'] for t in rich_text])
                    language = block[block_type].get('language', 'text')
                    return f"```{language}\n{text}\n```"
                
                return None
            
            async def generate_embedding(self, text: str) -> Optional[List[float]]:
                """Generate embedding for text content"""
                try:
                    # Truncate text to fit embedding model limits
                    max_length = 8000
                    if len(text) > max_length:
                        text = text[:max_length] + "..."
                    
                    response = await self.openai_client.embeddings.create(
                        model=self.embedding_model,
                        input=text,
                        dimensions=self.embedding_dimensions
                    )
                    
                    return response.data[0].embedding
                
                except Exception as e:
                    logger.error(f"Error generating embedding: {e}")
                    return None
            
            async def store_knowledge_fragment(self, conn: asyncpg.Connection, page: Dict, embedding: List[float]):
                """Store knowledge fragment in database"""
                try:
                    # Get organization ID (assuming default org exists)
                    org_result = await conn.fetchrow(
                        "SELECT id FROM organizations WHERE name = $1", 
                        "Sophia AI Intelligence"
                    )
                    org_id = str(org_result['id']) if org_result else None
                    
                    # Store knowledge fragment
                    await conn.execute("""
                        INSERT INTO knowledge_fragments (
                            organization_id, fragment_type, title, content, tags,
                            confidence_score, source_type, source_reference,
                            embedding_vector, created_by
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                        ON CONFLICT (organization_id, title) DO UPDATE SET
                            content = EXCLUDED.content,
                            embedding_vector = EXCLUDED.embedding_vector,
                            updated_at = NOW()
                    """, 
                    org_id, 'knowledge', page['title'], page['content'],
                    json.dumps(['notion', 'knowledge_base']),
                    0.9, 'notion', page['url'], embedding, 'notion_sync'
                    )
                    
                    logger.info(f"Stored knowledge fragment: {page['title']}")
                
                except Exception as e:
                    logger.error(f"Error storing knowledge fragment {page['title']}: {e}")
            
            async def sync_knowledge(self, sync_type: str = 'incremental') -> Dict:
                """Main sync function"""
                start_time = time.time()
                stats = {
                    'pages_processed': 0,
                    'pages_stored': 0,
                    'errors': []
                }
                
                try:
                    conn = await self.get_db_connection()
                    
                    # Get Notion pages
                    database_id = os.getenv('NOTION_DATABASE_ID')
                    pages = await self.get_notion_pages(database_id)
                    
                    logger.info(f"Found {len(pages)} pages in Notion")
                    
                    for page in pages:
                        try:
                            # Generate embedding
                            embedding = await self.generate_embedding(
                                f"{page['title']}\n\n{page['content']}"
                            )
                            
                            if embedding:
                                await self.store_knowledge_fragment(conn, page, embedding)
                                stats['pages_stored'] += 1
                            
                            stats['pages_processed'] += 1
                            
                        except Exception as e:
                            error_msg = f"Error processing page {page['title']}: {str(e)}"
                            stats['errors'].append(error_msg)
                            logger.error(error_msg)
                    
                    await conn.close()
                    
                    stats['execution_time_ms'] = int((time.time() - start_time) * 1000)
                    logger.info(f"Sync completed: {stats['pages_stored']}/{stats['pages_processed']} pages stored")
                    
                except Exception as e:
                    error_msg = f"Critical sync error: {str(e)}"
                    stats['errors'].append(error_msg)
                    logger.error(error_msg)
                
                return stats
        
        async def main():
            notion_token = os.getenv('NOTION_API_KEY')
            openai_api_key = os.getenv('OPENAI_API_KEY')
            database_url = os.getenv('DATABASE_URL')
            sync_type = os.getenv('SYNC_TYPE', 'incremental')
            
            if not all([notion_token, openai_api_key, database_url]):
                print("Missing required environment variables")
                return
            
            sync = NotionKnowledgeSync(notion_token, openai_api_key, database_url)
            stats = await sync.sync_knowledge(sync_type)
            
            print(f"Sync Results:")
            print(f"Pages processed: {stats['pages_processed']}")
            print(f"Pages stored: {stats['pages_stored']}")
            print(f"Execution time: {stats['execution_time_ms']}ms")
            print(f"Errors: {len(stats['errors'])}")
            
            # Generate proof
            proof = {
                "status": "success" if len(stats['errors']) == 0 else "partial",
                "query": f"Notion knowledge sync - {sync_type}",
                "results": [stats],
                "summary": {
                    "text": f"Notion sync processed {stats['pages_processed']} pages, stored {stats['pages_stored']}",
                    "confidence": 1.0,
                    "model": "notion_sync",
                    "sources": ["notion_api", "openai_embeddings", "postgresql"]
                },
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "execution_time_ms": stats['execution_time_ms'],
                "errors": [{"provider": "notion_sync", "code": "PROCESSING_ERROR", "message": err} for err in stats['errors']]
            }
            
            with open('proofs/knowledge/notion_sync_scaffold.json', 'w') as f:
                json.dump(proof, f, indent=2)
        
        if __name__ == "__main__":
            asyncio.run(main())
        EOF
    
    - name: Run Notion sync
      env:
        NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
        NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        DATABASE_URL: ${{ secrets.NEON_DATABASE_URL }}
        SYNC_TYPE: ${{ github.event.inputs.sync_type || 'incremental' }}
      run: |
        python notion_sync.py
    
    - name: Upload sync artifacts
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: notion-sync-results
        path: |
          proofs/knowledge/notion_sync_scaffold.json
          proofs/knowledge/notion_sync_blocked.json
        retention-days: 30
    
    - name: Commit sync proof
      if: always()
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add proofs/knowledge/
        if git diff --cached --quiet; then
          echo "No sync proof changes to commit"
        else
          git commit -m "[auto] Notion knowledge sync proof - $(date +%Y-%m-%d)"
          git push
        fi
    
    - name: Update Context MCP with new knowledge
      if: success()
      run: |
        # Trigger Context MCP to refresh knowledge cache
        curl -X POST "https://sophiaai-mcp-context-v2.fly.dev/internal/refresh-knowledge" \
          -H "Content-Type: application/json" \
          -d '{"source": "notion_sync", "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' \
          || echo "⚠️ Could not notify Context MCP of knowledge update"

  validate-sync-results:
    needs: notion-knowledge-sync
    runs-on: ubuntu-latest
    if: always() && github.repository == 'ai-cherry/sophia-ai-intel'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Download sync artifacts
      uses: actions/download-artifact@v3
      with:
        name: notion-sync-results
        path: sync-results/
    
    - name: Validate sync results
      run: |
        echo "Validating Notion sync results..."
        
        if [ -f "sync-results/notion_sync_scaffold.json" ]; then
          echo "✅ Sync proof generated successfully"
          
          # Parse results
          pages_processed=$(jq -r '.results[0].pages_processed // 0' sync-results/notion_sync_scaffold.json)
          pages_stored=$(jq -r '.results[0].pages_stored // 0' sync-results/notion_sync_scaffold.json)
          errors=$(jq -r '.errors | length' sync-results/notion_sync_scaffold.json)
          
          echo "📊 Sync Statistics:"
          echo "   Pages processed: $pages_processed"
          echo "   Pages stored: $pages_stored"
          echo "   Errors: $errors"
          
          if [ "$pages_stored" -gt 0 ]; then
            echo "✅ Knowledge fragments successfully synced to database"
          else
            echo "⚠️ No knowledge fragments were stored"
          fi
          
        elif [ -f "sync-results/notion_sync_blocked.json" ]; then
          echo "❌ Notion sync blocked - configuration required"
          jq -r '.errors[0].message' sync-results/notion_sync_blocked.json
          
        else
          echo "❌ No sync results found"
          exit 1
        fi
    
    - name: Generate validation summary
      run: |
        cat > proofs/knowledge/sync_validation_$(date +%Y%m%d).json << EOF
        {
          "status": "$([ -f "sync-results/notion_sync_scaffold.json" ] && echo "validated" || echo "blocked")",
          "query": "Notion knowledge sync validation",
          "results": [
            {
              "validation_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "sync_successful": $([ -f "sync-results/notion_sync_scaffold.json" ] && echo "true" || echo "false"),
              "configuration_complete": $([ ! -f "sync-results/notion_sync_blocked.json" ] && echo "true" || echo "false"),
              "workflow_operational": true
            }
          ],
          "summary": {
            "text": "Notion sync workflow validation completed",
            "confidence": 1.0,
            "model": "validation_system",
            "sources": ["github_actions", "notion_api", "database_integration"]
          },
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "execution_time_ms": 0,
          "errors": []
        }
        EOF