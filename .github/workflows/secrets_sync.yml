name: Runtime Secrets Sync

on:
  workflow_dispatch:
    inputs:
      sync_mode:
        description: "Secrets sync operation mode"
        type: choice
        required: true
        default: "sync_all"
        options:
          - "sync_all"
          - "rotate_secrets"
          - "audit_only"
          - "emergency_clear"
      target_apps:
        description: "Target apps (comma-separated or 'all')"
        type: string
        default: "all"
        required: true
      rolling_restart:
        description: "Perform rolling restart after sync"
        type: boolean
        default: true
      dry_run:
        description: "Dry run mode (no actual changes)"
        type: boolean
        default: false

concurrency:
  group: secrets-sync-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: read

env:
  FLY_ORG: pay-ready
  SECRETS_WEBHOOK_URL: ${{ secrets.SECRETS_WEBHOOK_URL }}

jobs:
  secrets-audit-preparation:
    name: Secrets Audit & Preparation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      apps-matrix: ${{ steps.apps.outputs.matrix }}
      secrets-count: ${{ steps.audit.outputs.secrets_count }}
      sync-timestamp: ${{ steps.setup.outputs.sync_timestamp }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install flyctl and tools
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Setup sync parameters
        id: setup
        run: |
          SYNC_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          SYNC_ID="${{ github.run_id }}"
          
          echo "üîê Runtime Secrets Sync Initiated"
          echo "Mode: ${{ inputs.sync_mode }}"
          echo "Target Apps: ${{ inputs.target_apps }}"
          echo "Rolling Restart: ${{ inputs.rolling_restart }}"
          echo "Dry Run: ${{ inputs.dry_run }}"
          echo "Sync ID: $SYNC_ID"
          echo "Timestamp: $SYNC_TIMESTAMP"
          
          echo "sync_timestamp=$SYNC_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "sync_id=$SYNC_ID" >> $GITHUB_OUTPUT
          
          # Create sync metadata
          mkdir -p proofs/secrets/sync
          cat > proofs/secrets/sync/sync_metadata_$SYNC_ID.json <<EOF
          {
            "sync_id": "$SYNC_ID",
            "timestamp": "$SYNC_TIMESTAMP",
            "mode": "${{ inputs.sync_mode }}",
            "target_apps": "${{ inputs.target_apps }}",
            "rolling_restart": ${{ inputs.rolling_restart }},
            "dry_run": ${{ inputs.dry_run }},
            "triggered_by": "${{ github.actor }}",
            "github_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF

      - name: Authenticate with Fly.io
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"
            exit 1
          fi
          echo "‚úÖ Fly.io authentication configured"

      - name: Discover target applications
        id: apps
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üîç Discovering target applications..."
          
          # Get all apps from fly.toml files
          apps_json="["
          first=true
          
          if [ "${{ inputs.target_apps }}" = "all" ]; then
            # Find all fly.toml files and extract app names
            for toml_file in $(find . -name "fly.toml" -type f); do
              if [ "$first" = false ]; then
                apps_json="$apps_json,"
              fi
              
              app_name=$(grep '^app = ' "$toml_file" | sed 's/app = "\(.*\)"/\1/' | tr -d '"'"'"'')
              directory=$(dirname "$toml_file")
              
              # Determine service type
              service_type="service"
              if [[ "$directory" == *"dashboard"* ]]; then
                service_type="dashboard"
              elif [[ "$directory" == *"jobs"* ]]; then
                service_type="jobs"
              fi
              
              apps_json="$apps_json{\"app\":\"$app_name\",\"directory\":\"$directory\",\"type\":\"$service_type\"}"
              first=false
              
              echo "Found: $app_name in $directory (type: $service_type)"
            done
          else
            # Parse comma-separated app list
            IFS=',' read -ra APP_ARRAY <<< "${{ inputs.target_apps }}"
            for app_name in "${APP_ARRAY[@]}"; do
              app_name=$(echo "$app_name" | xargs) # trim whitespace
              
              if [ "$first" = false ]; then
                apps_json="$apps_json,"
              fi
              
              apps_json="$apps_json{\"app\":\"$app_name\",\"directory\":\"unknown\",\"type\":\"manual\"}"
              first=false
              
              echo "Target: $app_name (manual)"
            done
          fi
          
          apps_json="$apps_json]"
          echo "Apps matrix: $apps_json"
          echo "matrix=$apps_json" >> $GITHUB_OUTPUT
          
          # Save to proof file
          echo "$apps_json" > proofs/secrets/sync/apps_matrix_${{ github.run_id }}.json

      - name: Audit current secrets state
        id: audit
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_APP_SECRETS_JSON: ${{ secrets.FLY_APP_SECRETS_JSON }}
        run: |
          echo "üîç Auditing current secrets state..."
          
          if [ -z "$FLY_APP_SECRETS_JSON" ]; then
            echo "‚ö†Ô∏è FLY_APP_SECRETS_JSON not provided - only audit mode available"
            echo "secrets_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          secrets_count=$(echo "$FLY_APP_SECRETS_JSON" | jq 'length')
          echo "secrets_count=$secrets_count" >> $GITHUB_OUTPUT
          echo "üìä Found $secrets_count secrets to sync"
          
          # Create current secrets audit
          apps='${{ steps.apps.outputs.matrix }}'
          audit_data="{"
          first=true
          
          for app in $(echo "$apps" | jq -r '.[].app'); do
            echo "Auditing secrets for: $app"
            
            if [ "$first" = false ]; then
              audit_data="$audit_data,"
            fi
            
            # Get current app secrets (only keys, not values)
            current_secrets=$(flyctl secrets list -a "$app" --json 2>/dev/null || echo "[]")
            secret_keys=$(echo "$current_secrets" | jq -r '.[].Name' | sort | jq -R . | jq -s .)
            
            audit_data="$audit_data\"$app\":{\"current_secret_keys\":$secret_keys,\"secret_count\":$(echo "$secret_keys" | jq 'length')}"
            first=false
          done
          
          audit_data="$audit_data}"
          echo "$audit_data" | jq . > proofs/secrets/sync/pre_sync_audit_${{ github.run_id }}.json
          
          echo "‚úÖ Secrets audit completed"

      - name: Send sync start notification
        if: ${{ env.SECRETS_WEBHOOK_URL != '' && inputs.dry_run != true }}
        env:
          WEBHOOK_URL: ${{ env.SECRETS_WEBHOOK_URL }}
        run: |
          echo "üì° Sending secrets sync start notification..."
          
          payload=$(cat <<EOF
          {
            "text": "üîê Secrets Sync Started",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Runtime Secrets Sync Started*\n\n*Mode:* ${{ inputs.sync_mode }}\n*Target Apps:* ${{ inputs.target_apps }}\n*Sync ID:* ${{ github.run_id }}\n*Triggered by:* ${{ github.actor }}\n*Time:* $(date -u)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Configuration:*\n‚Ä¢ Rolling Restart: ${{ inputs.rolling_restart }}\n‚Ä¢ Secrets Count: ${{ steps.audit.outputs.secrets_count }}\n‚Ä¢ Apps Count: $(echo '${{ steps.apps.outputs.matrix }}' | jq 'length')"
                }
              }
            ]
          }
          EOF
          )
          
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send sync notification"

  secrets-sync-execution:
    name: Sync Secrets to Applications
    runs-on: ubuntu-latest
    needs: secrets-audit-preparation
    if: ${{ inputs.sync_mode != 'audit_only' }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.secrets-audit-preparation.outputs.apps-matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Authenticate with Fly.io
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"
            exit 1
          fi

      - name: Execute secrets sync for ${{ matrix.app }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_APP_SECRETS_JSON: ${{ secrets.FLY_APP_SECRETS_JSON }}
        run: |
          echo "üîê Syncing secrets to ${{ matrix.app }}..."
          mkdir -p proofs/secrets/sync
          
          SYNC_START=$(date +%s)
          SYNC_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          sync_success="true"
          sync_error=""
          secrets_updated=0
          
          if [ "${{ inputs.sync_mode }}" = "emergency_clear" ]; then
            echo "üö® EMERGENCY CLEAR: Removing all secrets from ${{ matrix.app }}"
            
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "DRY RUN: Would clear all secrets"
            else
              # Get current secrets and clear them
              current_secrets=$(flyctl secrets list -a "${{ matrix.app }}" --json 2>/dev/null || echo "[]")
              for secret in $(echo "$current_secrets" | jq -r '.[].Name'); do
                echo "  Clearing secret: $secret"
                flyctl secrets unset "$secret" -a "${{ matrix.app }}" --yes || echo "    Failed to clear $secret"
                secrets_updated=$((secrets_updated + 1))
              done
            fi
          elif [ "${{ inputs.sync_mode }}" = "sync_all" ] || [ "${{ inputs.sync_mode }}" = "rotate_secrets" ]; then
            if [ -z "$FLY_APP_SECRETS_JSON" ]; then
              echo "‚ùå FLY_APP_SECRETS_JSON required for sync operations"
              sync_success="false"
              sync_error="Missing FLY_APP_SECRETS_JSON"
            else
              echo "üîÑ Syncing secrets to ${{ matrix.app }}..."
              
              # Process each secret
              echo "$FLY_APP_SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while read -r secret; do
                key=$(echo "$secret" | cut -d'=' -f1)
                value=$(echo "$secret" | cut -d'=' -f2-)
                
                if [ -n "$value" ] && [ "$value" != "null" ]; then
                  echo "  Syncing secret: $key"
                  
                  if [ "${{ inputs.dry_run }}" = "true" ]; then
                    echo "    DRY RUN: Would set $key"
                  else
                    if flyctl secrets set "$key=$value" -a "${{ matrix.app }}"; then
                      echo "    ‚úÖ Successfully set $key"
                      secrets_updated=$((secrets_updated + 1))
                    else
                      echo "    ‚ùå Failed to set $key"
                      sync_success="false"
                    fi
                  fi
                fi
              done
              
              # Update secrets_updated count for the parent process
              echo $secrets_updated > /tmp/secrets_updated_count
            fi
          fi
          
          # Read back the count if it was updated in subshell
          if [ -f /tmp/secrets_updated_count ]; then
            secrets_updated=$(cat /tmp/secrets_updated_count)
          fi
          
          SYNC_END=$(date +%s)
          SYNC_DURATION=$((SYNC_END - SYNC_START))
          
          echo "SYNC_SUCCESS=$sync_success" >> $GITHUB_ENV
          echo "SECRETS_UPDATED=$secrets_updated" >> $GITHUB_ENV
          echo "SYNC_DURATION=$SYNC_DURATION" >> $GITHUB_ENV
          
          # Create sync report for this app
          sync_report=$(cat <<EOF
          {
            "timestamp": "$SYNC_TIMESTAMP",
            "sync_id": "${{ github.run_id }}",
            "app": "${{ matrix.app }}",
            "service_type": "${{ matrix.type }}",
            "sync_mode": "${{ inputs.sync_mode }}",
            "dry_run": ${{ inputs.dry_run }},
            "sync_results": {
              "success": $sync_success,
              "error": "$sync_error",
              "secrets_updated": $secrets_updated,
              "sync_duration_seconds": $SYNC_DURATION
            }
          }
          EOF
          )
          
          echo "$sync_report" | jq . > proofs/secrets/sync/${{ matrix.app }}_sync_${{ github.run_id }}.json
          
          echo "üìä Sync summary for ${{ matrix.app }}:"
          echo "  Success: $sync_success"
          echo "  Secrets updated: $secrets_updated"
          echo "  Duration: ${SYNC_DURATION}s"

      - name: Perform rolling restart
        if: ${{ inputs.rolling_restart == true && inputs.dry_run != true && env.SYNC_SUCCESS == 'true' }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üîÑ Performing rolling restart for ${{ matrix.app }}..."
          
          RESTART_START=$(date +%s)
          
          # Get machine IDs
          machines=$(flyctl machines list -a "${{ matrix.app }}" --json 2>/dev/null || echo "[]")
          machine_count=$(echo "$machines" | jq 'length')
          
          if [ "$machine_count" -eq 0 ]; then
            echo "‚ö†Ô∏è No machines found for ${{ matrix.app }}"
            exit 0
          fi
          
          echo "üîÑ Found $machine_count machines to restart"
          
          # Restart machines with rolling strategy
          restarted=0
          for machine_id in $(echo "$machines" | jq -r '.[].id'); do
            echo "  Restarting machine: $machine_id"
            
            if flyctl machines restart "$machine_id" -a "${{ matrix.app }}" --yes; then
              echo "    ‚úÖ Machine $machine_id restarted successfully"
              restarted=$((restarted + 1))
              
              # Wait between restarts for rolling deployment
              if [ $restarted -lt $machine_count ]; then
                echo "    Waiting 10s before next restart..."
                sleep 10
              fi
            else
              echo "    ‚ùå Failed to restart machine $machine_id"
            fi
          done
          
          RESTART_END=$(date +%s)
          RESTART_DURATION=$((RESTART_END - RESTART_START))
          
          echo "MACHINES_RESTARTED=$restarted" >> $GITHUB_ENV
          echo "RESTART_DURATION=$RESTART_DURATION" >> $GITHUB_ENV
          
          echo "üîÑ Rolling restart completed: $restarted/$machine_count machines"
          echo "‚è±Ô∏è Restart duration: ${RESTART_DURATION}s"

      - name: Verify service health post-sync
        if: ${{ inputs.dry_run != true && env.SYNC_SUCCESS == 'true' }}
        run: |
          echo "üè• Verifying service health for ${{ matrix.app }}..."
          
          # Determine service URL based on app name
          service_url=""
          case "${{ matrix.app }}" in
            *dashboard*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
            *mcp-repo*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
            *mcp-research*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
            *mcp-context*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
            *mcp-business*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
            *jobs*)
              service_url="https://${{ matrix.app }}.fly.dev"
              ;;
          esac
          
          if [ -n "$service_url" ]; then
            echo "Testing health endpoint: $service_url/healthz"
            
            # Wait for service to be ready after restart
            sleep 30
            
            health_status="unknown"
            for attempt in {1..5}; do
              if curl -f -sS "$service_url/healthz" > /dev/null 2>&1; then
                health_status="healthy"
                echo "‚úÖ ${{ matrix.app }} is healthy after sync"
                break
              else
                echo "‚ö†Ô∏è Health check attempt $attempt failed, retrying..."
                if [ $attempt -lt 5 ]; then
                  sleep 15
                fi
              fi
            done
            
            if [ "$health_status" != "healthy" ]; then
              echo "‚ùå ${{ matrix.app }} health check failed after sync"
            fi
            
            echo "HEALTH_STATUS=$health_status" >> $GITHUB_ENV
          else
            echo "‚ÑπÔ∏è No health check URL available for ${{ matrix.app }}"
            echo "HEALTH_STATUS=skipped" >> $GITHUB_ENV
          fi

      - name: Commit sync proofs
        if: always()
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/secrets/sync/${{ matrix.app }}_sync_${{ github.run_id }}.json 2>/dev/null || true
          
          if ! git diff --cached --quiet; then
            status_suffix=""
            if [ "${{ env.SYNC_SUCCESS }}" != "true" ]; then
              status_suffix=" - SYNC FAILED"
            elif [ "${{ env.HEALTH_STATUS }}" = "unhealthy" ]; then
              status_suffix=" - HEALTH CHECK FAILED"
            fi
            
            git commit -m "[secrets-sync] ${{ matrix.app }}: secrets sync ${{ inputs.sync_mode }}$status_suffix (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  secrets-sync-summary:
    name: Secrets Sync Summary & Notification
    runs-on: ubuntu-latest
    needs: [secrets-audit-preparation, secrets-sync-execution]
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull sync results
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Generate sync summary
        run: |
          echo "üìä Generating secrets sync summary..."
          mkdir -p proofs/secrets/sync
          
          # Analyze sync results
          apps_total=$(echo '${{ needs.secrets-audit-preparation.outputs.apps-matrix }}' | jq 'length')
          sync_success_count=0
          sync_failure_count=0
          
          if [ -d "proofs/secrets/sync" ]; then
            sync_success_count=$(find proofs/secrets/sync -name "*_sync_${{ github.run_id }}.json" -exec jq -r '.sync_results.success' {} \; 2>/dev/null | grep -c "true" || echo "0")
            sync_failure_count=$(find proofs/secrets/sync -name "*_sync_${{ github.run_id }}.json" -exec jq -r '.sync_results.success' {} \; 2>/dev/null | grep -c "false" || echo "0")
          fi
          
          overall_status="success"
          if [ "$sync_failure_count" -gt 0 ]; then
            overall_status="partial_failure"
          fi
          
          if [ "${{ needs.secrets-sync-execution.result }}" = "failure" ]; then
            overall_status="failure"
          fi
          
          # Create comprehensive summary
          summary_report=$(cat <<EOF
          {
            "sync_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "sync_mode": "${{ inputs.sync_mode }}",
            "target_apps": "${{ inputs.target_apps }}",
            "configuration": {
              "rolling_restart": ${{ inputs.rolling_restart }},
              "dry_run": ${{ inputs.dry_run }},
              "secrets_count": ${{ needs.secrets-audit-preparation.outputs.secrets-count }}
            },
            "results": {
              "overall_status": "$overall_status",
              "apps_total": $apps_total,
              "sync_success_count": $sync_success_count,
              "sync_failure_count": $sync_failure_count,
              "execution_result": "${{ needs.secrets-sync-execution.result }}"
            },
            "github_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "triggered_by": "${{ github.actor }}"
          }
          EOF
          )
          
          echo "$summary_report" | jq . > proofs/secrets/sync/sync_summary_${{ github.run_id }}.json
          
          echo "OVERALL_STATUS=$overall_status" >> $GITHUB_ENV
          echo "SYNC_SUCCESS_COUNT=$sync_success_count" >> $GITHUB_ENV
          echo "SYNC_FAILURE_COUNT=$sync_failure_count" >> $GITHUB_ENV

      - name: Send completion notification
        if: ${{ env.SECRETS_WEBHOOK_URL != '' && inputs.dry_run != true }}
        env:
          WEBHOOK_URL: ${{ env.SECRETS_WEBHOOK_URL }}
        run: |
          echo "üì° Sending secrets sync completion notification..."
          
          status_icon="‚úÖ"
          status_text="Success"
          
          if [ "${{ env.OVERALL_STATUS }}" = "partial_failure" ]; then
            status_icon="‚ö†Ô∏è"
            status_text="Partial Success"
          elif [ "${{ env.OVERALL_STATUS }}" = "failure" ]; then
            status_icon="‚ùå"
            status_text="Failed"
          fi
          
          payload=$(cat <<EOF
          {
            "text": "${status_icon} Secrets Sync Complete",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Runtime Secrets Sync Complete*\n\n*Status:* ${status_icon} ${status_text}\n*Mode:* ${{ inputs.sync_mode }}\n*Sync ID:* ${{ github.run_id }}\n*Completed:* $(date -u)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Results:*\n‚Ä¢ Successful: ${{ env.SYNC_SUCCESS_COUNT }}\n‚Ä¢ Failed: ${{ env.SYNC_FAILURE_COUNT }}\n‚Ä¢ Rolling Restart: ${{ inputs.rolling_restart }}\n\n*Next Steps:*\n‚Ä¢ Review sync proofs in \`proofs/secrets/sync/\`\n‚Ä¢ Monitor application health\n‚Ä¢ Update security documentation"
                }
              }
            ]
          }
          EOF
          )
          
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send completion notification"

      - name: Commit final sync summary
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/secrets/sync/
          
          if ! git diff --cached --quiet; then
            git commit -m "[secrets-sync] Final summary: ${{ inputs.sync_mode }} - ${{ env.OVERALL_STATUS }} (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

      - name: Generate workflow summary
        run: |
          echo "# üîê Runtime Secrets Sync Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Sync ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** ${{ inputs.sync_mode }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ env.OVERALL_STATUS }}" >> $GITHUB_STEP_SUMMARY
          echo "**Completed:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Apps Total:** $(echo '${{ needs.secrets-audit-preparation.outputs.apps-matrix }}' | jq 'length')" >> $GITHUB_STEP_SUMMARY
          echo "- **Successful Syncs:** ${{ env.SYNC_SUCCESS_COUNT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed Syncs:** ${{ env.SYNC_FAILURE_COUNT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolling Restart:** ${{ inputs.rolling_restart }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run:** ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìÅ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Sync summary: \`proofs/secrets/sync/sync_summary_${{ github.run_id }}.json\`" >> $GITHUB_STEP_SUMMARY
          echo "- Individual app results: \`proofs/secrets/sync/*_sync_${{ github.run_id }}.json\`" >> $GITHUB_STEP_SUMMARY
          echo "- Pre-sync audit: \`proofs/secrets/sync/pre_sync_audit_${{ github.run_id }}.json\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ env.OVERALL_STATUS }}" != "success" ]; then
            echo "## ‚ö†Ô∏è Action Items" >> $GITHUB_STEP_SUMMARY
            echo "- Review failed sync operations" >> $GITHUB_STEP_SUMMARY
            echo "- Check application health manually" >> $GITHUB_STEP_SUMMARY
            echo "- Consider re-running sync for failed apps" >> $GITHUB_STEP_SUMMARY
          fi