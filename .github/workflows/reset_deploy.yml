name: Reset & Deploy (Fly + Proofs) ‚Äî all cloud

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "What do you want to do?"
        type: choice
        required: true
        default: deploy
        options: [deploy, cancel, stop]
      recreate_apps:
        description: "Force recreate all Fly apps (destroys existing)"
        required: false
        type: boolean
        default: false
      seed_secrets:
        description: "Seed secrets to all apps from FLY_APP_SECRETS_JSON"
        required: false
        type: boolean
        default: true
      skip_dashboard:
        description: "Skip dashboard deployment"
        required: false
        type: boolean
        default: false
      skip_jobs:
        description: "Skip jobs deployment"
        required: false
        type: boolean
        default: false

concurrency:
  group: reset-deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  id-token: write
  actions: write

env:
  FLY_ORG: pay-ready
  FLY_PRIMARY_REGION: iad
  CACHE_BUSTER: ${{ github.run_id }}-${{ github.run_attempt }}
  # Service URLs for health checks
  DASHBOARD_URL: https://sophiaai-dashboard-v2.fly.dev
  MCP_REPO_URL: https://sophiaai-mcp-repo-v2.fly.dev
  MCP_RESEARCH_URL: https://sophiaai-mcp-research-v2.fly.dev
  MCP_CONTEXT_URL: https://sophiaai-mcp-context-v2.fly.dev
  MCP_BUSINESS_URL: https://sophiaai-mcp-business-v2.fly.dev
  JOBS_URL: https://sophiaai-jobs-v2.fly.dev
  # Observability
  POST_DEPLOY_WEBHOOK_URL: ${{ secrets.POST_DEPLOY_WEBHOOK_URL }}

jobs:
  preflight-security:
    if: ${{ inputs.mode == 'deploy' }}
    name: Preflight Security Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      security-status: ${{ steps.validation.outputs.status }}
      missing-secrets: ${{ steps.validation.outputs.missing }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate critical secrets
        id: validation
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_APP_SECRETS_JSON: ${{ secrets.FLY_APP_SECRETS_JSON }}
        run: |
          echo "üîê Performing preflight security validation..."
          
          missing_secrets=""
          validation_errors=""
          
          # Critical secret validation
          if [ -z "$FLY_API_TOKEN" ]; then
            missing_secrets="$missing_secrets FLY_API_TOKEN"
            validation_errors="$validation_errors\n‚ùå FLY_API_TOKEN is required for deployment"
          else
            echo "‚úÖ FLY_API_TOKEN present"
          fi
          
          # Validate FLY_APP_SECRETS_JSON format if provided
          if [ -n "$FLY_APP_SECRETS_JSON" ]; then
            if echo "$FLY_APP_SECRETS_JSON" | jq . > /dev/null 2>&1; then
              echo "‚úÖ FLY_APP_SECRETS_JSON is valid JSON"
              secret_count=$(echo "$FLY_APP_SECRETS_JSON" | jq 'length')
              echo "üìä Found $secret_count secrets to deploy"
            else
              validation_errors="$validation_errors\n‚ùå FLY_APP_SECRETS_JSON is not valid JSON"
            fi
          else
            echo "‚ö†Ô∏è  FLY_APP_SECRETS_JSON not provided - secrets will not be seeded"
          fi
          
          # Token format validation (basic)
          if [ -n "$FLY_API_TOKEN" ]; then
            if [[ ${#FLY_API_TOKEN} -lt 20 ]]; then
              validation_errors="$validation_errors\n‚ùå FLY_API_TOKEN appears too short"
            else
              echo "‚úÖ FLY_API_TOKEN format appears valid"
            fi
          fi
          
          # Report validation results
          if [ -n "$missing_secrets" ]; then
            echo "missing=$missing_secrets" >> $GITHUB_OUTPUT
            echo "status=failed" >> $GITHUB_OUTPUT
            echo -e "validation_errors$validation_errors" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Secret validation failed - missing:$missing_secrets"
            exit 1
          else
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "missing=" >> $GITHUB_OUTPUT
            echo "‚úÖ All critical secrets validated successfully"
          fi

      - name: Security scan recommendations
        run: |
          mkdir -p proofs/security
          cat > proofs/security/scan_recommendations.md <<EOF
          # Security Scanning Recommendations
          
          Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          Run ID: ${{ github.run_id }}
          
          ## Required Security Measures
          
          ### 1. Secret Rotation Schedule
          - **FLY_API_TOKEN**: Rotate every 90 days
          - **Application Secrets**: Rotate every 60 days
          - **Database Credentials**: Rotate every 30 days
          
          ### 2. Repository Security
          - Enable GitHub secret scanning
          - Enable push protection
          - Use Dependabot security updates
          - Regular dependency auditing
          
          ### 3. Fly.io Security
          - Use organization-scoped tokens
          - Enable audit logging
          - Monitor access patterns
          - Regular permission reviews
          
          ### 4. Deployment Security
          - All deployments require preflight validation
          - Secrets validated before deployment
          - Emergency rollback procedures tested
          - Audit trail for all changes
          
          ### 5. Monitoring & Alerting
          - Failed deployment notifications
          - Unusual access pattern alerts
          - Secret rotation reminders
          - Security event logging
          EOF

      - name: Commit security documentation
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/security/scan_recommendations.md
          if ! git diff --cached --quiet; then
            git commit -m "[security] Add security scanning recommendations (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  cancel-active:
    if: ${{ inputs.mode == 'cancel' }}
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    steps:
      - name: Cancel in-progress runs of reset_deploy.yml
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          echo "üõë Cancelling all active runs of reset_deploy.yml workflow..."
          wf_id=$(gh api repos/${{ github.repository }}/actions/workflows \
            --jq '.workflows[] | select(.path==".github/workflows/reset_deploy.yml") | .id')
          [ -n "$wf_id" ] || { echo "reset_deploy.yml not found"; exit 0; }
          gh api repos/${{ github.repository }}/actions/workflows/$wf_id/runs \
            -f status=in_progress --paginate \
            --jq '.workflow_runs[].id' | while read -r run; do
              if [ "$run" != "${{ github.run_id }}" ]; then
                echo "Cancelling run $run"
                gh api -X POST repos/${{ github.repository }}/actions/runs/$run/cancel
              fi
            done
          echo "‚úÖ All active runs cancelled."

  emergency-stop:
    if: ${{ inputs.mode == 'stop' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      FLY_ORG: ${{ env.FLY_ORG }}
    steps:
      - uses: actions/checkout@v4
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Install jq
        run: |
          sudo apt-get update && sudo apt-get install -y jq
      - name: Auth
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: test -n "$FLY_API_TOKEN"
      - name: Discover apps from fly.toml
        id: apps
        run: |
          apps="[]"
          for f in $(find . -name fly.toml -type f); do
            app=$(awk -F'"' '/^app =/ {print $2}' "$f")
            [ -n "$app" ] && apps=$(jq -rc --arg a "$app" '. + [$a]' <<<"$apps")
          done
          echo "apps=$apps" >> $GITHUB_OUTPUT
          echo "Apps: $apps"
      - name: Stop all machines (graceful)
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          set -euo pipefail
          echo "üõë Emergency stop: Gracefully stopping all Fly machines..."
          apps='${{ steps.apps.outputs.apps }}'
          for app in $(echo "$apps" | jq -r '.[]'); do
            echo "‚Üí $app"
            ids=$(flyctl machines list -a "$app" --json | jq -r '.[].id' 2>/dev/null || echo "")
            if [ -n "$ids" ]; then
              for id in $ids; do
                echo "  - stopping $id"
                flyctl machines stop "$id" -a "$app" --yes || true
              done
            else
              echo "  - no machines found or app doesn't exist"
            fi
          done
          echo "‚úÖ All machines issued stop command"

  app-management:
    if: ${{ inputs.mode == 'deploy' }}
    name: Create/Recreate Fly Apps
    runs-on: ubuntu-latest
    needs: preflight-security
    timeout-minutes: 15
    environment:
      name: production
      url: ${{ env.DASHBOARD_URL }}
    outputs:
      apps-matrix: ${{ steps.apps.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Fly auth
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"; exit 1
          fi
          echo "‚úÖ Fly token configured"

      - name: Parse fly.toml files and extract app names
        id: apps
        run: |
          mkdir -p proofs/fly
          echo "Scanning for fly.toml files..."
          
          apps_json="["
          first=true
          
          # Find all fly.toml files and extract app names
          for toml_file in $(find . -name "fly.toml" -type f); do
            if [ "$first" = false ]; then
              apps_json="$apps_json,"
            fi
            
            app_name=$(grep '^app = ' "$toml_file" | sed 's/app = "\(.*\)"/\1/' | tr -d '"'"'"'')
            directory=$(dirname "$toml_file")
            
            # Determine service type
            service_type="service"
            if [[ "$directory" == *"dashboard"* ]]; then
              service_type="dashboard"
            elif [[ "$directory" == *"jobs"* ]]; then
              service_type="jobs"
            fi
            
            apps_json="$apps_json{\"app\":\"$app_name\",\"directory\":\"$directory\",\"type\":\"$service_type\",\"toml\":\"$toml_file\"}"
            first=false
            
            echo "Found: $app_name in $directory (type: $service_type)"
          done
          
          apps_json="$apps_json]"
          echo "Apps matrix: $apps_json"
          echo "matrix=$apps_json" >> $GITHUB_OUTPUT
          
          # Save to proof file
          echo "$apps_json" > proofs/fly/apps_matrix.json

      - name: Destroy existing apps (if recreate requested)
        if: ${{ inputs.recreate_apps == true }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üî• RECREATE MODE: Destroying existing apps..."
          apps='${{ steps.apps.outputs.matrix }}'
          
          for app in $(echo "$apps" | jq -r '.[].app'); do
            echo "Destroying app: $app"
            flyctl apps destroy $app --yes || echo "App $app didn't exist or couldn't be destroyed"
          done

      - name: Create all Fly apps (idempotent)
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          apps='${{ steps.apps.outputs.matrix }}'
          
          echo "Creating apps in organization: $FLY_ORG"
          for app in $(echo "$apps" | jq -r '.[].app'); do
            echo "Creating app: $app"
            flyctl apps create "$app" --org "$FLY_ORG" --region "$FLY_PRIMARY_REGION" || echo "App $app already exists."
          done

      - name: Seed secrets from FLY_APP_SECRETS_JSON
        if: ${{ inputs.seed_secrets == true }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_APP_SECRETS_JSON: ${{ secrets.FLY_APP_SECRETS_JSON }}
        run: |
          if [ -z "$FLY_APP_SECRETS_JSON" ]; then
            echo "‚ö†Ô∏è  FLY_APP_SECRETS_JSON not provided, skipping secrets seeding"
            exit 0
          fi
          
          echo "üîê Seeding secrets to all apps..."
          apps='${{ steps.apps.outputs.matrix }}'
          
          # Parse secrets JSON and set for each app
          for app in $(echo "$apps" | jq -r '.[].app'); do
            echo "Setting secrets for: $app"
            
            # Extract secrets and set them individually
            echo "$FLY_APP_SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while read -r secret; do
              key=$(echo "$secret" | cut -d'=' -f1)
              value=$(echo "$secret" | cut -d'=' -f2-)
              
              if [ -n "$value" ] && [ "$value" != "null" ]; then
                echo "  Setting $key for $app"
                flyctl secrets set "$key=$value" -a "$app" || echo "  Failed to set $key for $app"
              fi
            done
          done

      - name: Save app management proof
        run: |
          mkdir -p proofs/deployment
          cat > proofs/deployment/app_management_${{ github.run_id }}.json <<EOF
          {
            "run_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "recreate_apps": ${{ inputs.recreate_apps }},
            "seed_secrets": ${{ inputs.seed_secrets }},
            "apps_found": $(echo '${{ steps.apps.outputs.matrix }}' | jq length),
            "apps": ${{ steps.apps.outputs.matrix }}
          }
          EOF

      - name: Commit app management proofs
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/fly/apps_matrix.json proofs/deployment/app_management_${{ github.run_id }}.json
          if ! git diff --cached --quiet; then
            git commit -m "[proof] app management: created/recreated apps (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  deploy-dashboard:
    name: Deploy Dashboard
    if: ${{ inputs.mode == 'deploy' && inputs.skip_dashboard != true }}
    runs-on: ubuntu-latest
    needs: app-management
    timeout-minutes: 30
    environment:
      name: production
      url: ${{ env.DASHBOARD_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pull latest proofs
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Install flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Fly auth
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"; exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build dashboard (resilient install)
        working-directory: apps/dashboard
        run: |
          echo "üèóÔ∏è  Building dashboard with fallback install logic..."
          
          # Try standard install first
          if npm ci --no-audit --no-fund; then
            echo "‚úÖ Standard npm ci succeeded"
          elif npm ci --no-audit --no-fund --legacy-peer-deps; then
            echo "‚úÖ npm ci with --legacy-peer-deps succeeded"
          elif npm install --no-audit --no-fund --legacy-peer-deps; then
            echo "‚úÖ npm install with --legacy-peer-deps succeeded"
          else
            echo "‚ùå All install methods failed"
            exit 1
          fi
          
          # Build the project
          npm run build

      - name: Deploy dashboard (remote build)
        working-directory: apps/dashboard
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          VITE_BUILD_ID: ${{ github.run_id }}
        run: |
          set -e
          if [ -f ./Dockerfile.static ]; then
            DOCKERFILE_ARG="--dockerfile ./Dockerfile.static"
          else
            DOCKERFILE_ARG=""
          fi
          flyctl deploy \
            --config ./fly.toml \
            $DOCKERFILE_ARG \
            --build-arg VITE_BUILD_ID \
            --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
            --remote-only \
            --yes

      - name: Health check dashboard
        run: |
          echo "üè• Performing dashboard health check..."
          mkdir -p proofs/healthz
          
          # Wait for deployment to be ready
          sleep 30
          
          # Health check with retries (enhanced for production reliability)
          for i in {1..8}; do
            if curl -f -sS "${DASHBOARD_URL}/healthz"; then
              echo "‚úÖ Dashboard health check passed on attempt $i"
              break
            else
              echo "‚ö†Ô∏è  Dashboard health check failed on attempt $i, retrying..."
              if [ $i -eq 8 ]; then
                echo "‚ùå Dashboard health check failed after 8 attempts - triggering rollback"
                exit 1
              fi
              sleep 15
            fi
          done
          
          # Capture detailed health proof
          echo "====== $(date -u) ${DASHBOARD_URL}/healthz ======" | tee proofs/healthz/sophiaai-dashboard-v2.txt
          curl -i -sS "${DASHBOARD_URL}/healthz" | tee -a proofs/healthz/sophiaai-dashboard-v2.txt || echo "Health check failed"
          echo "" >> proofs/healthz/sophiaai-dashboard-v2.txt

      - name: Capture build info
        if: always()
        run: |
          mkdir -p proofs/build
          echo "====== $(date -u) ${DASHBOARD_URL}/__build ======" | tee proofs/build/dashboard_build.txt
          curl -sS "${DASHBOARD_URL}/__build" | tee -a proofs/build/dashboard_build.txt || echo "Build endpoint failed"

      - name: Enhanced auto-rollback on dashboard failure
        if: failure()
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üîÑ Dashboard deployment failed - executing enhanced rollback..."
          mkdir -p proofs/rollback
          
          ROLLBACK_START=$(date +%s)
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Get current and previous release information
          releases=$(flyctl apps releases -a sophiaai-dashboard-v2 --json 2>/dev/null || echo "[]")
          current_version=$(echo "$releases" | jq -r '.[0].version // "unknown"')
          previous_version=$(echo "$releases" | jq -r '.[1].version // "unknown"')
          previous_image=$(echo "$releases" | jq -r '.[1].image_ref // "unknown"')
          
          rollback_success="false"
          rollback_error=""
          
          if [ "$previous_version" != "unknown" ] && [ "$previous_version" != "null" ]; then
            echo "üìä Rollback Details:"
            echo "  Current (failed) version: $current_version"
            echo "  Rolling back to version: $previous_version"
            echo "  Previous image: $previous_image"
            
            if flyctl releases rollback "$previous_version" -a sophiaai-dashboard-v2 --yes; then
              echo "‚úÖ Dashboard rollback to v$previous_version successful"
              rollback_success="true"
              
              # Wait and verify rollback
              sleep 30
              if curl -f -sS "${DASHBOARD_URL}/healthz" > /dev/null 2>&1; then
                echo "‚úÖ Dashboard health check passed after rollback"
              else
                echo "‚ö†Ô∏è Dashboard health check failed after rollback"
              fi
            else
              rollback_error="Failed to execute flyctl rollback command"
              echo "‚ùå Dashboard rollback failed: $rollback_error"
            fi
          else
            rollback_error="No previous version available for rollback"
            echo "‚ùå $rollback_error"
          fi
          
          ROLLBACK_END=$(date +%s)
          ROLLBACK_DURATION=$((ROLLBACK_END - ROLLBACK_START))
          
          # Create detailed rollback report
          rollback_report=$(cat <<EOF
          {
            "timestamp": "$ROLLBACK_TIMESTAMP",
            "app": "sophiaai-dashboard-v2",
            "trigger": "deployment_failure",
            "github_run_id": "${{ github.run_id }}",
            "github_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "rollback_details": {
              "failed_version": "$current_version",
              "rollback_target_version": "$previous_version",
              "rollback_target_image": "$previous_image",
              "rollback_duration_seconds": $ROLLBACK_DURATION,
              "rollback_success": $rollback_success,
              "rollback_error": "$rollback_error"
            },
            "recovery_instructions": {
              "manual_rollback_command": "flyctl releases rollback $previous_version -a sophiaai-dashboard-v2",
              "health_check_url": "${DASHBOARD_URL}/healthz",
              "logs_command": "flyctl logs -a sophiaai-dashboard-v2",
              "one_click_recovery_url": "https://github.com/${{ github.repository }}/actions/workflows/reset_deploy.yml"
            }
          }
          EOF
          )
          
          echo "$rollback_report" | jq . > proofs/rollback/dashboard_rollback_${{ github.run_id }}.json
          
          # Add failure summary with GitHub run links
          echo "## üîÑ Dashboard Rollback Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** $([ "$rollback_success" = "true" ] && echo "‚úÖ Success" || echo "‚ùå Failed")" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${ROLLBACK_DURATION} seconds" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Version:** $current_version" >> $GITHUB_STEP_SUMMARY
          echo "**Rollback Target:** $previous_version" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ One-Click Recovery Options" >> $GITHUB_STEP_SUMMARY
          echo "- [Re-run Failed Deployment](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Trigger New Deployment](https://github.com/${{ github.repository }}/actions/workflows/reset_deploy.yml)" >> $GITHUB_STEP_SUMMARY
          echo "- [View Dashboard Health](${DASHBOARD_URL}/healthz)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ†Ô∏è Manual Recovery Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Manual rollback if needed" >> $GITHUB_STEP_SUMMARY
          echo "flyctl releases rollback $previous_version -a sophiaai-dashboard-v2" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check logs for troubleshooting" >> $GITHUB_STEP_SUMMARY
          echo "flyctl logs -a sophiaai-dashboard-v2" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verify health after recovery" >> $GITHUB_STEP_SUMMARY
          echo "curl -i ${DASHBOARD_URL}/healthz" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Commit dashboard proofs and rollback data
        if: always()
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/healthz/sophiaai-dashboard-v2.txt proofs/build/dashboard_build.txt proofs/rollback/dashboard_rollback_${{ github.run_id }}.json 2>/dev/null || true
          if ! git diff --cached --quiet; then
            if [ "${{ job.status }}" = "failure" ]; then
              git commit -m "[proof] dashboard: FAILED deployment + rollback attempted (run ${{ github.run_id }})"
            else
              git commit -m "[proof] dashboard: health check + build info (run ${{ github.run_id }})"
            fi
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  deploy-services:
    name: Deploy MCP Services
    if: ${{ inputs.mode == 'deploy' }}
    runs-on: ubuntu-latest
    needs: app-management
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: mcp-github
            app: sophiaai-mcp-repo-v2
            directory: services/mcp-github
            url: ${{ env.MCP_REPO_URL }}
          - name: mcp-research
            app: sophiaai-mcp-research-v2
            directory: services/mcp-research
            url: ${{ env.MCP_RESEARCH_URL }}
          - name: mcp-context
            app: sophiaai-mcp-context-v2
            directory: services/mcp-context
            url: ${{ env.MCP_CONTEXT_URL }}
          - name: mcp-business
            app: sophiaai-mcp-business-v2
            directory: services/mcp-business
            url: ${{ env.MCP_BUSINESS_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pull latest proofs
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Install flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Fly auth
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"; exit 1
          fi

      - name: Deploy ${{ matrix.name }} (remote build)
        working-directory: ${{ matrix.directory }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üöÄ Deploying ${{ matrix.name }} with remote build..."
          flyctl deploy \
            --config ./fly.toml \
            --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
            --remote-only \
            --yes

      - name: Roll machines to new image
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üîÑ Rolling machines for ${{ matrix.app }}..."
          
          # Get machine IDs and restart them
          IDS=$(flyctl machines list -a ${{ matrix.app }} --json | jq -r '.[] | select(.state=="started") | .id')
          for ID in $IDS; do
            echo "  Restarting machine $ID"
            flyctl machines restart $ID -a ${{ matrix.app }} --yes || echo "  Failed to restart $ID"
          done

      - name: Health check ${{ matrix.name }}
        env:
          TARGET_URL: ${{ matrix.url }}
        run: |
          echo "üè• Performing health check for ${{ matrix.name }}..."
          mkdir -p proofs/healthz
          
          # Wait for deployment to be ready
          sleep 30
          
          # Health check with retries (enhanced for production reliability)
          for i in {1..8}; do
            if curl -f -sS "${TARGET_URL}/healthz"; then
              echo "‚úÖ ${{ matrix.name }} health check passed on attempt $i"
              break
            else
              echo "‚ö†Ô∏è  ${{ matrix.name }} health check failed on attempt $i, retrying..."
              if [ $i -eq 8 ]; then
                echo "‚ùå ${{ matrix.name }} health check failed after 8 attempts - triggering rollback"
                exit 1
              fi
              sleep 20
            fi
          done
          
          # Capture detailed health proof
          echo "====== $(date -u) ${TARGET_URL}/healthz ======" | tee proofs/healthz/${{ matrix.name }}.txt
          curl -i -sS "${TARGET_URL}/healthz" | tee -a proofs/healthz/${{ matrix.name }}.txt || echo "Health check failed"
          echo "" >> proofs/healthz/${{ matrix.name }}.txt

      - name: Capture machine state
        if: always()
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          mkdir -p proofs/fly
          flyctl machines list -a ${{ matrix.app }} --json | tee proofs/fly/${{ matrix.app }}_machines.json

      - name: Capture logs on failure
        if: failure()
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          mkdir -p proofs/fly
          flyctl logs -a ${{ matrix.app }} --since 15m | tail -n 200 > proofs/fly/${{ matrix.app }}_logs.txt || true

      - name: Enhanced auto-rollback on service failure
        if: failure()
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üîÑ ${{ matrix.name }} deployment failed - executing enhanced rollback..."
          mkdir -p proofs/rollback
          
          ROLLBACK_START=$(date +%s)
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Get detailed release information
          releases=$(flyctl apps releases -a ${{ matrix.app }} --json 2>/dev/null || echo "[]")
          current_version=$(echo "$releases" | jq -r '.[0].version // "unknown"')
          previous_version=$(echo "$releases" | jq -r '.[1].version // "unknown"')
          previous_image=$(echo "$releases" | jq -r '.[1].image_ref // "unknown"')
          
          rollback_success="false"
          rollback_error=""
          service_url="${{ matrix.url }}"
          
          if [ "$previous_version" != "unknown" ] && [ "$previous_version" != "null" ]; then
            echo "üìä Rollback Details for ${{ matrix.name }}:"
            echo "  App: ${{ matrix.app }}"
            echo "  Current (failed) version: $current_version"
            echo "  Rolling back to version: $previous_version"
            echo "  Previous image: $previous_image"
            
            if flyctl releases rollback "$previous_version" -a ${{ matrix.app }} --yes; then
              echo "‚úÖ ${{ matrix.name }} rollback to v$previous_version successful"
              rollback_success="true"
              
              # Wait and verify rollback
              sleep 30
              if curl -f -sS "${service_url}/healthz" > /dev/null 2>&1; then
                echo "‚úÖ ${{ matrix.name }} health check passed after rollback"
              else
                echo "‚ö†Ô∏è ${{ matrix.name }} health check failed after rollback"
              fi
            else
              rollback_error="Failed to execute flyctl rollback command"
              echo "‚ùå ${{ matrix.name }} rollback failed: $rollback_error"
            fi
          else
            rollback_error="No previous version available for rollback"
            echo "‚ùå $rollback_error"
          fi
          
          ROLLBACK_END=$(date +%s)
          ROLLBACK_DURATION=$((ROLLBACK_END - ROLLBACK_START))
          
          # Create detailed rollback report
          rollback_report=$(cat <<EOF
          {
            "timestamp": "$ROLLBACK_TIMESTAMP",
            "service": "${{ matrix.name }}",
            "app": "${{ matrix.app }}",
            "service_url": "$service_url",
            "trigger": "deployment_failure",
            "github_run_id": "${{ github.run_id }}",
            "github_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "rollback_details": {
              "failed_version": "$current_version",
              "rollback_target_version": "$previous_version",
              "rollback_target_image": "$previous_image",
              "rollback_duration_seconds": $ROLLBACK_DURATION,
              "rollback_success": $rollback_success,
              "rollback_error": "$rollback_error"
            },
            "recovery_instructions": {
              "manual_rollback_command": "flyctl releases rollback $previous_version -a ${{ matrix.app }}",
              "health_check_url": "${service_url}/healthz",
              "logs_command": "flyctl logs -a ${{ matrix.app }}",
              "machine_restart_command": "flyctl machines restart -a ${{ matrix.app }}",
              "one_click_recovery_url": "https://github.com/${{ github.repository }}/actions/workflows/reset_deploy.yml"
            }
          }
          EOF
          )
          
          echo "$rollback_report" | jq . > proofs/rollback/${{ matrix.name }}_rollback_${{ github.run_id }}.json
          
          # Update step summary with detailed rollback info
          echo "## üîÑ ${{ matrix.name }} Rollback Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ matrix.name }} (${{ matrix.app }})" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** $([ "$rollback_success" = "true" ] && echo "‚úÖ Success" || echo "‚ùå Failed")" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${ROLLBACK_DURATION} seconds" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Version:** $current_version" >> $GITHUB_STEP_SUMMARY
          echo "**Rollback Target:** $previous_version" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ One-Click Recovery Options" >> $GITHUB_STEP_SUMMARY
          echo "- [Re-run Failed Deployment](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Trigger New Deployment](https://github.com/${{ github.repository }}/actions/workflows/reset_deploy.yml)" >> $GITHUB_STEP_SUMMARY
          echo "- [View Service Health](${service_url}/healthz)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ†Ô∏è Manual Recovery Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Manual rollback if needed" >> $GITHUB_STEP_SUMMARY
          echo "flyctl releases rollback $previous_version -a ${{ matrix.app }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Restart machines if needed" >> $GITHUB_STEP_SUMMARY
          echo "flyctl machines restart -a ${{ matrix.app }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check logs for troubleshooting" >> $GITHUB_STEP_SUMMARY
          echo "flyctl logs -a ${{ matrix.app }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verify health after recovery" >> $GITHUB_STEP_SUMMARY
          echo "curl -i ${service_url}/healthz" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Commit service proofs and rollback data
        if: always()
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/healthz/${{ matrix.name }}.txt proofs/fly/${{ matrix.app }}_machines.json proofs/fly/${{ matrix.app }}_logs.txt proofs/rollback/${{ matrix.name }}_rollback_${{ github.run_id }}.json 2>/dev/null || true
          if ! git diff --cached --quiet; then
            if [ "${{ job.status }}" = "failure" ]; then
              git commit -m "[proof] ${{ matrix.name }}: FAILED deployment + rollback attempted (run ${{ github.run_id }})"
            else
              git commit -m "[proof] ${{ matrix.name }}: health check + machines (run ${{ github.run_id }})"
            fi
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  deploy-jobs:
    name: Deploy Jobs Service
    if: ${{ inputs.mode == 'deploy' && inputs.skip_jobs != true }}
    runs-on: ubuntu-latest
    needs: app-management
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pull latest proofs
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Install flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Fly auth
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          if [ -z "$FLY_API_TOKEN" ]; then
            echo "‚ùå Missing FLY_API_TOKEN secret"; exit 1
          fi

      - name: Deploy jobs (remote build)
        working-directory: jobs
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          echo "üöÄ Deploying jobs service with remote build..."
          flyctl deploy \
            --config ./fly.toml \
            --build-arg CACHE_BUSTER=${CACHE_BUSTER} \
            --remote-only \
            --yes

      - name: Capture jobs deployment state
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          mkdir -p proofs/fly
          flyctl machines list -a sophiaai-jobs-v2 --json | tee proofs/fly/sophiaai-jobs-v2_machines.json
          
          # Capture job-specific proof
          mkdir -p proofs/jobs
          cat > proofs/jobs/deployment_${{ github.run_id }}.json <<EOF
          {
            "run_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "app": "sophiaai-jobs-v2",
            "deployment_method": "remote_build",
            "status": "deployed"
          }
          EOF

      - name: Commit jobs proofs
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/fly/sophiaai-jobs-v2_machines.json proofs/jobs/deployment_${{ github.run_id }}.json 2>/dev/null || true
          if ! git diff --cached --quiet; then
            git commit -m "[proof] jobs: deployment complete (run ${{ github.run_id }})"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

  final-verification:
    name: Final Health Verification & Summary
    runs-on: ubuntu-latest
    needs: [cancel-active, emergency-stop, deploy-dashboard, deploy-services, deploy-jobs]
    if: always()
    outputs:
      dashboard_url: ${{ env.DASHBOARD_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pull all proofs
        run: |
          git pull origin ${GITHUB_REF#refs/heads/}

      - name: Comprehensive health verification
        run: |
          echo "üè• Running comprehensive health verification..."
          mkdir -p proofs/deployment
          
          if [ "${{ inputs.mode }}" = "deploy" ]; then
            declare -A services=(
              ["dashboard"]="${DASHBOARD_URL}"
              ["mcp-repo"]="${MCP_REPO_URL}"
              ["mcp-research"]="${MCP_RESEARCH_URL}"
              ["mcp-context"]="${MCP_CONTEXT_URL}"
              ["mcp-business"]="${MCP_BUSINESS_URL}"
            )
            
            if [ "${{ inputs.skip_dashboard }}" = "true" ]; then
              unset services[dashboard]
            fi
            
            health_results="{"
            first=true
            
            for service in "${!services[@]}"; do
              url="${services[$service]}/healthz"
              
              if [ "$first" = false ]; then
                health_results="$health_results,"
              fi
              
              if curl -f -sS "$url" > /dev/null 2>&1; then
                status="healthy"
                echo "‚úÖ $service: healthy"
              else
                status="unhealthy"
                echo "‚ùå $service: unhealthy"
              fi
              
              health_results="$health_results\"$service\":\"$status\""
              first=false
            done
            
            health_results="$health_results}"
          else
            health_results="{}"
          fi
          
          # Create comprehensive summary
          cat > proofs/deployment/reset_deploy_summary_${{ github.run_id }}.json <<EOF
          {
            "run_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "ref": "${GITHUB_REF}",
            "sha": "${GITHUB_SHA}",
            "actor": "${{ github.actor }}",
            "mode": "${{ inputs.mode }}",
            "inputs": {
              "recreate_apps": ${{ inputs.recreate_apps }},
              "seed_secrets": ${{ inputs.seed_secrets }},
              "skip_dashboard": ${{ inputs.skip_dashboard }},
              "skip_jobs": ${{ inputs.skip_jobs }}
            },
            "deployment_status": {
              "dashboard": ${{ needs.deploy-dashboard.result == 'success' || inputs.skip_dashboard == true || inputs.mode != 'deploy' }},
              "services": ${{ needs.deploy-services.result == 'success' || inputs.mode != 'deploy' }},
              "jobs": ${{ needs.deploy-jobs.result == 'success' || inputs.skip_jobs == true || inputs.mode != 'deploy' }}
            },
            "control_operations": {
              "cancel_active": ${{ needs.cancel-active.result == 'success' || inputs.mode != 'cancel' }},
              "emergency_stop": ${{ needs.emergency-stop.result == 'success' || inputs.mode != 'stop' }}
            },
            "health_checks": $health_results,
            "service_urls": {
              "dashboard": "${DASHBOARD_URL}",
              "mcp_repo": "${MCP_REPO_URL}",
              "mcp_research": "${MCP_RESEARCH_URL}",
              "mcp_context": "${MCP_CONTEXT_URL}",
              "mcp_business": "${MCP_BUSINESS_URL}",
              "jobs": "${JOBS_URL}"
            }
          }
          EOF

      - name: Generate deployment report
        run: |
          # Generate different reports based on mode
          if [ "${{ inputs.mode }}" = "cancel" ]; then
            echo "# üõë Workflow Cancellation Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Mode:** Cancel Active Runs" >> $GITHUB_STEP_SUMMARY
            echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
            echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
            echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Operation Status" >> $GITHUB_STEP_SUMMARY
            echo "- **Cancel Active Runs:** ${{ needs.cancel-active.result }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All in-progress workflow runs have been cancelled." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.mode }}" = "stop" ]; then
            echo "# üõë Emergency Stop Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Mode:** Emergency Stop" >> $GITHUB_STEP_SUMMARY
            echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
            echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
            echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Operation Status" >> $GITHUB_STEP_SUMMARY
            echo "- **Emergency Stop:** ${{ needs.emergency-stop.result }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All Fly machines have been gracefully stopped." >> $GITHUB_STEP_SUMMARY
          else
            echo "# üöÄ Reset & Deploy Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Mode:** Deploy" >> $GITHUB_STEP_SUMMARY
            echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
            echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
            echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Deployment Status" >> $GITHUB_STEP_SUMMARY
            echo "- **Dashboard:** ${{ needs.deploy-dashboard.result }} ${{ inputs.skip_dashboard == true && '(skipped)' || '' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **MCP Services:** ${{ needs.deploy-services.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Jobs Service:** ${{ needs.deploy-jobs.result }} ${{ inputs.skip_jobs == true && '(skipped)' || '' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Service URLs" >> $GITHUB_STEP_SUMMARY
            echo "- **Dashboard:** [${DASHBOARD_URL}](${DASHBOARD_URL})" >> $GITHUB_STEP_SUMMARY
            echo "- **MCP Repository:** [${MCP_REPO_URL}](${MCP_REPO_URL})" >> $GITHUB_STEP_SUMMARY
            echo "- **MCP Research:** [${MCP_RESEARCH_URL}](${MCP_RESEARCH_URL})" >> $GITHUB_STEP_SUMMARY
            echo "- **MCP Context:** [${MCP_CONTEXT_URL}](${MCP_CONTEXT_URL})" >> $GITHUB_STEP_SUMMARY
            echo "- **MCP Business:** [${MCP_BUSINESS_URL}](${MCP_BUSINESS_URL})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Proof Artifacts" >> $GITHUB_STEP_SUMMARY
            echo "- Health checks: \`proofs/healthz/\`" >> $GITHUB_STEP_SUMMARY
            echo "- Machine states: \`proofs/fly/\`" >> $GITHUB_STEP_SUMMARY
            echo "- Deployment summaries: \`proofs/deployment/\`" >> $GITHUB_STEP_SUMMARY
            echo "- Build artifacts: \`proofs/build/\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload comprehensive deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-proofs-${{ github.run_id }}
          path: |
            proofs/
          retention-days: 30

      - name: Commit final summary
        run: |
          git config user.name "sophia-bot"
          git config user.email "sophia-bot@users.noreply.github.com"
          git add proofs/deployment/reset_deploy_summary_${{ github.run_id }}.json
          if ! git diff --cached --quiet; then
            if [ "${{ inputs.mode }}" = "cancel" ]; then
              git commit -m "[proof] workflow control: cancel active runs (run ${{ github.run_id }})"
            elif [ "${{ inputs.mode }}" = "stop" ]; then
              git commit -m "[proof] workflow control: emergency stop (run ${{ github.run_id }})"
            else
              git commit -m "[proof] reset & deploy: final summary (run ${{ github.run_id }})"
            fi
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi

      - name: Send deployment notifications
        if: ${{ env.POST_DEPLOY_WEBHOOK_URL != '' && inputs.mode == 'deploy' }}
        env:
          WEBHOOK_URL: ${{ env.POST_DEPLOY_WEBHOOK_URL }}
        run: |
          echo "üì° Sending deployment notification to webhook..."
          
          # Prepare notification payload
          deployment_status="success"
          if [[ "${{ needs.deploy-dashboard.result }}" == "failure" ]] || [[ "${{ needs.deploy-services.result }}" == "failure" ]] || [[ "${{ needs.deploy-jobs.result }}" == "failure" ]]; then
            deployment_status="failure"
          fi
          
          payload=$(cat <<EOF
          {
            "text": "üöÄ Sophia AI Deployment ${deployment_status}",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Sophia AI Infrastructure Deployment*\n\n*Status:* ${deployment_status}\n*Run ID:* ${{ github.run_id }}\n*Triggered by:* ${{ github.actor }}\n*Timestamp:* $(date -u)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Service Status:*\n‚Ä¢ Dashboard: ${{ needs.deploy-dashboard.result }}\n‚Ä¢ MCP Services: ${{ needs.deploy-services.result }}\n‚Ä¢ Jobs: ${{ needs.deploy-jobs.result }}"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Service URLs:*\n‚Ä¢ <${DASHBOARD_URL}|Dashboard>\n‚Ä¢ <${MCP_REPO_URL}|MCP Repository>\n‚Ä¢ <${MCP_RESEARCH_URL}|MCP Research>\n‚Ä¢ <${MCP_CONTEXT_URL}|MCP Context>\n‚Ä¢ <${MCP_BUSINESS_URL}|MCP Business>"
                }
              }
            ]
          }
          EOF
          )
          
          # Send notification
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send webhook notification"
          
          echo "‚úÖ Deployment notification sent"